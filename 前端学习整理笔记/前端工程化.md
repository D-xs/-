## nodejs

> nodejs是一个基于js v8引擎的应用程序，可以在浏览器外执行js代码，并且可以通过js来进行一些系统操作，如读写文件、网络操作等等。
>
> 前端工程化中node是最底层的运行环境。
>
> nvm-windows：这个工具可以在电脑里管理多个不同版本的node，可以在任意时候切换不同的node版本





## 模块化

> 模块化是指将一个复杂的程序或系统分解成多个相对独立的、可重用的模块。每个模块都有特定的功能，可以独立开发、测试和维护。
>
> 每一个模块可以看作一个单独的js文件，每个模块有自己的作用域；模块化的**核心**就是**导入**和**导出**。



模块化的主要特点和优势包括：

1. 封装性：模块可以隐藏内部实现细节，只暴露必要的接口。
2. 可重用性：模块可以在不同的项目中重复使用，提高开发效率。
3. 可维护性：由于代码被分割成小的、独立的单元，更容易理解和维护。
4. 命名空间：模块可以避免全局命名冲突，每个模块有自己的作用域。
5. 依赖管理：模块可以明确声明它们的依赖关系，使得代码结构更清晰。



在 JavaScript 中，实现模块化的方式经历了几个阶段：

1. 早期的模块模式：使用立即执行函数表达式（IIFE）创建私有作用域。
2. CommonJS：主要用于服务器端 JavaScript（Node.js），使用 `require()` 和 `module.exports`
3. AMD（Asynchronous Module Definition）：主要用于浏览器端，支持异步加载模块。
4. ES6 模块：JavaScript 的官方模块系统，使用 `import` 和 `export` 语句。



### commonjs规范

> 通过exports导出，通过require函数进行导入。
>
> 缺点：commonjs加载和解析模块是同步的，容易造成阻塞。

- 导出的本质

  > 在nodejs中，通过exports进行导出，只不过exports是module.exports的引用拷贝。
  >
  > 在node中的cjs规范实现下：导出的本质是导出的是当前模块的module.exports这个属性对应的对象。exports和require的本质就是引用赋值。

  ```js
  // a.js
  let name = "dd";
  let age = 33;
  function foo() {
    console.log("foo exe");
  }
  
  exports.name = name;
  exports.age = age;
  
  console.log(exports === module.exports); // true
  
  module.exports = {
    name: "18",
    age: 18,
  };
  
  console.log(exports === module.exports, "222"); // false "222"
  
  // b.js
  const b = require("./a.js");
  console.log("b", b); // b { name: '18', age: 18 }
  ```

- 导入的本质

  > 通过require函数将对应模块导出的module.exports对象引用返回。

- require函数的工作原理

  > require函数的查找规则可以分为以下几种情况：
  >
  > 1. 核心模块
  >
  > 2. 文件模块
  >
  > 3. 目录作为模块
  >
  > 4. node_modules 目录
  >
  > 5. 全局模块

  ```js
  // 1. 核心模块
  const fs = require('fs');
  const http = require('http');
  
  // 2. 文件模块
  const myModule = require('./myModule');           // myModule.js
  const jsonData = require('./data.json');          // JSON 文件
  const compiled = require('./example.node');       // 编译的插件
  
  // 3. 目录作为模块
  const directoryModule = require('./myDirectory'); // 查找 myDirectory/index.js
  
  // 4. node_modules 目录
  const lodash = require('lodash');                 // 查找 node_modules/lodash
  
  // 5. 全局模块
  // 假设我们有一个全局安装的模块 'globalModule'
  const globalMod = require('globalModule');
  
  // 目录结构示例：
  // project/
  // ├── node_modules/
  // │   └── lodash/
  // ├── myDirectory/
  // │   └── index.js
  // ├── myModule.js
  // ├── data.json
  // ├── example.node
  // └── main.js
  
  // main.js 中的 require 调用
  ```

- 核心模块：

  - 这些是 Node.js 自带的模块，如 'fs'、'http' 等。
  - 它们的优先级最高，即使在 node_modules 目录中有同名模块，也会优先加载核心模块。

- 文件模块：

  - 以 './'、'../' 或 '/' 开头的模块标识符被视为文件模块。
  - Node.js 会尝试按以下顺序解析： a) 精确的文件名 b) 带 .js 扩展名 c) 带 .json 扩展名 d) 带 .node 扩展名（编译的插件）

- 目录作为模块：

  - 如果 require() 指向一个目录，Node.js 会尝试查找该目录下的 package.json 文件，并加载其中 "main" 字段指定的文件。
  - 如果没有 package.json 或 "main" 入口，则会尝试加载目录下的 index.js、index.json 或 index.node。

- node_modules 目录：

  - 如果模块名不是核心模块且不以 '/'、'./' 或 '../' 开头，Node.js 会从当前目录的 node_modules 开始，沿着目录层次向上查找，直到找到匹配的模块或到达文件系统的根目录。

- 全局模块：

  - 如果模块在本地的 node_modules 中找不到，Node.js 会在全局安装路径中查找（例如 /usr/local/lib/node_modules/）。



### node模块的加载过程

1. 模块在被第一次引入时，模块中的js代码会被运行一次。
2. 模块被多次引入时，会缓存，最终只加载一次。
   1. 为什么只会加载运行一次？
   2. 这是因为每个模块对象module都有一个属性：loaded
   3. 为false表示还没有加载，为true表示已经加载
3. 如果有循环引入，加载顺序通过深度优先算法来进行执行的



### ES Module规范

> ES Module是在前端开发中的模块化规范，在浏览器中实现。
>
> 通过export导出，通过import进行导入。
>
> ps：采用ES Module将自动采用严格模式解析执行代码：“use strict”
>
> ES6模块化主要有以下几种使用方式：
>
> 1. 命名导出和导入
> 2. 默认导出和导入
> 3. 混合使用命名导出和默认导出
> 4. 重命名导出和导入
> 5. 导入所有
> 6. 动态导入

1. 命名导出和导入：

   - 使用 `export` 关键字导出变量、函数或类。

   - 使用 `import { ... } from '...'` 语法导入。

   - 可以一次导出/导入多个项目。

     ```js
     // math.js
     // 1. 命名导出
     export const PI = 3.14159;
     export function add(a, b) {
       return a + b;
     }
     
     // main.js
     // 1. 命名导入
     import { PI, add } from './math.js';
     console.log(PI);  // 3.14159
     console.log(add(2, 3));  // 5
     ```

2. 默认导出和导入：

   - 每个模块只能有一个默认导出，使用 `export default` 语法。

   - 使用 `import name from '...'` 语法导入，其中 `name` 可以是任意标识符。

     ```js
     // math.js
     // 2. 默认导出
     export default function multiply(a, b) {
       return a * b;
     }
     
     // main.js
     // 2. 默认导入
     import multiply from './math.js';
     console.log(multiply(4, 5));  // 20
     ```

3. 混合使用命名导出和默认导出

   - 一个模块可以同时包含命名导出和默认导出。

   - 导入时可以同时导入默认导出和命名导出。

     ```js
     // utils.js
     // 3. 混合使用命名导出和默认导出
     export const VERSION = '1.0.0';
     export function formatDate(date) {
       return date.toISOString();
     }
     
     export default class Logger {
       log(message) {
         console.log(`[LOG]: ${message}`);
       }
     }
     
     // main.js
     // 3. 混合导入
     import Logger, { VERSION } from './utils.js';
     const logger = new Logger();
     logger.log(VERSION);  // [LOG]: 1.0.0
     ```

4. 重命名导出和导入

   - 导出时可以使用 `as` 关键字重命名。

   - 导入时也可以使用 `as` 关键字重命名。

     ```js
     // utils.js
     export function formatDate(date) {
       return date.toISOString();
     }
     // 4. 重命名导出
     export { formatDate as formatISO };
     
     
     // main.js
     // 4. 重命名导入
     import { formatISO, formatDate as format } from './utils.js';
     ```

     

5. 导入所有：

   - 使用 `import * as name from '...'` 语法可以将模块的所有导出作为一个对象导入。

   - 默认导出会成为这个对象的 `default` 属性。

     ```js
     // math.js
     // 命名导出
     export const PI = 3.14159;
     export function add(a, b) {
       return a + b;
     }
     
     // 默认导出
     export default function multiply(a, b) {
       return a * b;
     }
     
     
     // 5. 导入所有
     import * as mathModule from './math.js';
     console.log(mathModule.PI);  // 3.14159
     console.log(mathModule.default(2, 3));  // 6 (使用默认导出的multiply函数)
     ```

6. 动态导入：

   - 使用 `import()` 函数可以在运行时动态导入模块。

   - 返回一个 Promise，resolve 的值是模块对象。

     ```JS
     // math.js
     // 命名导出
     export const PI = 3.14159;
     export function add(a, b) {
       return a + b;
     }
     
     // 默认导出
     export default function multiply(a, b) {
       return a * b;
     }
     
     // 6. 动态导入
     import('./math.js').then(mathModule => {
       console.log(mathModule.add(5, 7));  // 12
     });
     ```



### ES Module的解析流程

> 阶段一：构建（Construction），根据地址查找js文件，并且下载，将其解析成模块记录（Module Record）；
>
> 阶段二：实例化（Instantiation），对模块记录进行实例化，并且分配内存空间，解析模块的导入和导出语句，把模块指向对应的内存地址。
>
> 阶段三：运行（Evaluation），运行代码，计算值，并且将值填充到内存地址中；



**构建阶段**：

![img](https://hacks.mozilla.org/wp-content/uploads/2018/03/10_construction.png)

当浏览器下载完main.js模块文件时，开始解析，会给该模块生成对应的模块记录（Module Record），记录该模块的导入和导出信息，根据导入的信息，下载对应的模块并解析，生成对应的模块记录，记录对应模块的导入和导出信息。当解析完成后开始对模块记录进行实例化。

![img](https://hacks.mozilla.org/wp-content/uploads/2018/03/25_module_map.png)

一个ES 模块文件（js文件）对应一个模块记录。



**实例化和运行：**实例化时，每一个模块记录会对应生成一个模块环境记录，这个模块环境记录中记录了导入和导出标识符的信息。当运行时，填充对应导出标识符的值。

![img](https://hacks.mozilla.org/wp-content/uploads/2018/03/30_live_bindings_04.png)

ps：不能在导入的位置修改导入的变量值。可以在导出的模块修改导出变量的值。只有导入和导出的便利才会存在模块环境记录中。